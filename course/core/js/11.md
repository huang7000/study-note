# 第 11 章 期约与异步函数

## 异步编程

:::code 同步与异步

ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。
ECMAScript 6 使用 async 和 await 关键字定义异步函数的机制。

同步行为和异步行为的对立统一是计算机科学的一个基本概念。
特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。
异步行为是为了优化因计算量大而时间长的操作。
如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。
同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地的信息。

```js
let x = 3;
console.log("setTimeout前x的值：" + x);
setTimeout(() => {
  x = x + 4;
  console.log("setTimeout中x的值：" + x);
}, 1000);
console.log("setTimeout后x的值：" + x);
//setTimeout前x的值：3
//setTimeout后x的值：3
//setTimeout中x的值：7
```

:::

:::code 以往的异步编程模式

```js
let x = 3;
console.log("setTimeout前x的值：" + x);
setTimeout(() => {
  x = x + 4;
  console.log("setTimeout中x的值：" + x);
}, 1000);
console.log("setTimeout后x的值：" + x);
//setTimeout前x的值：3
//setTimeout后x的值：3
//setTimeout中x的值：7
```

:::

## 期约

:::code 期约基础

ECMAScript 6 新增的引用类型 Promise（期约异步编程机制），可以通过 new 操作符来实例化。
创建新期约时需要传入执行器（executor）函数作为参数。

期约是一个有状态的对象，可能处于如下 3 种状态之一：

- 待定（pending）
- 兑现（fulfilled，有时候也称为“解决”，resolved）
- 拒绝（rejected）

待定（pending）是期约的最初始状态。
在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。
无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。

执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。
控制期约状态的转换是通过调用它的两个函数参数实现的。两个函数参数: resolve()和 reject()。
调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。调用 reject()也会抛出错误。

```js
let p = new Promise(() => {});
console.log(p); //Promise {<pending>}
let p1 = new Promise((resolve, reject) => resolve());
console.log(p1); // Promise <resolved>
let p2 = new Promise((resolve, reject) => reject());
console.log(p2); // Promise <rejected>
// Uncaught error (in promise)

//执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。
new Promise(() => setTimeout(console.log, 0, "executor"));
setTimeout(console.log, 0, "promise initialized");
// executor
// promise initialized

//添加 setTimeout 可以推迟切换状态：
let p3 = new Promise((resolve, reject) => setTimeout(resolve, 1000));
// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）
setTimeout(console.log, 0, p3); // Promise <pending>

//无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：
let p4 = new Promise((resolve, reject) => {
  resolve();
  reject(); // 没有效果
});
setTimeout(console.log, 0, p4); // Promise <resolved>

// 为避免期约卡在待定状态，可以添加一个定时退出功能。
let p5 = new Promise((resolve, reject) => {
  setTimeout(reject, 5000); // 10 秒后调用 reject()
  // 执行函数的逻辑
});
setTimeout(console.log, 0, p5); // Promise <pending>
setTimeout(console.log, 6000, p5); // 11 秒后再检查状态
// (After 5 seconds) Uncaught error
// (After 6 seconds) Promise <rejected>

//通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。
let p6 = new Promise((resolve, reject) => resolve());
let p7 = Promise.resolve();
setTimeout(console.log, 0, Promise.resolve()); // Promise <resolved>: undefined
setTimeout(console.log, 0, Promise.resolve(3)); // Promise <resolved>: 3
// 多余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)); // Promise <resolved>: 4
//Promise.resolve()可以说是一个幂等方法，
let p8 = Promise.resolve(7);
setTimeout(console.log, 0, p8 === Promise.resolve(p8));
// true
setTimeout(console.log, 0, p8 === Promise.resolve(Promise.resolve(p8)));
// true

//与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。
//两个期约实例实际上是一样的
let p9 = new Promise((resolve, reject) => reject());
let p10 = Promise.reject();
let p11 = Promise.reject(3);
setTimeout(console.log, 0, p11); // Promise <rejected>: 3
p11.then(null, e => setTimeout(console.log, 0, e)); // 3

//Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：
setTimeout(console.log, 0, Promise.reject(Promise.resolve())); // Promise <rejected>: Promise <resolved>

//第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到。
try {
  throw new Error("foo");
} catch (e) {
  console.log(e); // Error: foo
}
try {
  Promise.reject(new Error("bar"));
} catch (e) {
  console.log(e);
}
// Uncaught (in promise) Error: bar
```

:::

:::code 期约的实例方法
期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。
这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

1. 实现 Thenable 接口。Promise 类型实现了 Thenable 接口。
2. Promise.prototype.then() 两个参数：onResolved 处理程序和 onRejected 处理程序。
3. Promise.prototype.catch()方法用于给期约添加拒绝处理程序。相当于调用 Promise.prototype.then(null, onRejected)。
4. Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。
5. 非重入期约方法。当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。
6. 邻近处理程序的执行顺序。如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。
7. 传递解决值和拒绝理由。期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。
8. 拒绝期约与拒绝错误处理。拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。

:::

:::code Promise.prototype.then()

```js
function onResolved(id) {
  setTimeout(console.log, 0, id, "resolved");
}
function onRejected(id) {
  setTimeout(console.log, 0, id, "rejected");
}
let promise1 = new Promise((resolve, reject) => setTimeout(resolve, 3000));
let promise2 = new Promise((resolve, reject) => setTimeout(reject, 3000));
promise1.then(() => onResolved("promise1"), () => onRejected("promise1"));
promise2.then(() => onResolved("promise2"), () => onRejected("promise2"));
//（3 秒后）
// promise1 resolved
// promise2 rejected

let p1 = Promise.reject("foo");
// 调用 then()时不传处理程序则原样向后传
let p2 = p1.then();
// Uncaught (in promise) foo
// 这些都一样
let p3 = p1.then(null, () => undefined);
let p4 = p1.then(null, () => {});
let p5 = p1.then(null, () => Promise.resolve());
setTimeout(console.log, 0, p3); // Promise <resolved>: undefined
setTimeout(console.log, 0, p4); // Promise <resolved>: undefined
setTimeout(console.log, 0, p5); // Promise <resolved>: undefined
// 这些都一样
let p6 = p1.then(null, () => "bar");
let p7 = p1.then(null, () => Promise.resolve("bar"));
setTimeout(console.log, 0, p6); // Promise <resolved>: bar
setTimeout(console.log, 0, p7); // Promise <resolved>: bar
// Promise.resolve()保留返回的期约
let p8 = p1.then(null, () => new Promise(() => {}));
let p9 = p1.then(null, () => Promise.reject());
// Uncaught (in promise): undefined
setTimeout(console.log, 0, p8); // Promise <pending>
setTimeout(console.log, 0, p9); // Promise <rejected>: undefined
let p10 = p1.then(null, () => {
  throw "baz";
});
// Uncaught (in promise) baz
setTimeout(console.log, 0, p10); // Promise <rejected>: baz
let p11 = p1.then(null, () => Error("qux"));
setTimeout(console.log, 0, p11); // Promise <resolved>: Error: qux
```

:::

:::code Promise.prototype.then()

```js
let p = Promise.reject();
let onRejected = function(e) {
  setTimeout(console.log, 0, "rejected");
};
// 这两种添加拒绝处理程序的方式是一样的：
p.then(null, onRejected); // rejected
p.catch(onRejected); // rejected
let p1 = new Promise(() => {});
let p2 = p1.catch();
setTimeout(console.log, 0, p1); // Promise <pending>
setTimeout(console.log, 0, p2); // Promise <pending>
setTimeout(console.log, 0, p1 === p2); // false
```

:::

:::code Promise.prototype.finally()

```js
let p1 = Promise.resolve();
let p2 = Promise.reject();
let onFinally = function() {
  setTimeout(console.log, 0, "Finally!");
};
p1.finally(onFinally); // Finally
p2.finally(onFinally); // Finally
//Promise.prototype.finally()方法返回一个新的期约实例：
let p3 = new Promise(() => {});
let p4 = p3.finally();
setTimeout(console.log, 0, p3); // Promise <pending>
setTimeout(console.log, 0, p4); // Promise <pending>
setTimeout(console.log, 0, p3 === p4); // false

let p11 = Promise.resolve("foo");
// 这里都会原样后传
let p21 = p11.finally();
let p31 = p11.finally(() => undefined);
let p41 = p11.finally(() => {});
let p51 = p11.finally(() => Promise.resolve());
let p61 = p11.finally(() => "bar");
let p71 = p11.finally(() => Promise.resolve("bar"));
let p81 = p11.finally(() => Error("qux"));
setTimeout(console.log, 0, p21); // Promise <resolved>: foo
setTimeout(console.log, 0, p31); // Promise <resolved>: foo
setTimeout(console.log, 0, p41); // Promise <resolved>: foo
setTimeout(console.log, 0, p51); // Promise <resolved>: foo
setTimeout(console.log, 0, p61); // Promise <resolved>: foo
setTimeout(console.log, 0, p71); // Promise <resolved>: foo
setTimeout(console.log, 0, p81); // Promise <resolved>: foo
```

:::

:::code 非重入期约方法

```js
let synchronousResolve;
// 创建一个期约并将解决函数保存在一个局部变量中
let p = new Promise(resolve => {
  synchronousResolve = function() {
    console.log("1: invoking resolve()");
    resolve();
    console.log("2: resolve() returns");
  };
});
p.then(() => console.log("4: then() handler executes"));
synchronousResolve();
console.log("3: synchronousResolve() returns");
// 实际的输出：
// 1: invoking resolve()
// 2: resolve() returns
// 3: synchronousResolve() returns
// 4: then() handler executes

let p1 = Promise.resolve();
p1.then(() => console.log("p1.then() onResolved"));
console.log("p1.then() returns");
let p2 = Promise.reject();
p2.then(null, () => console.log("p2.then() onRejected"));
console.log("p2.then() returns");
let p3 = Promise.reject();
p3.catch(() => console.log("p3.catch() onRejected"));
console.log("p3.catch() returns");
let p4 = Promise.resolve();
p4.finally(() => console.log("p4.finally() onFinally"));
console.log("p4.finally() returns");
// p1.then() returns
// p2.then() returns
// p3.catch() returns
// p4.finally() returns
// p1.then() onResolved
// p2.then() onRejected
// p3.catch() onRejected
// p4.finally() onFinally
```

:::

:::code 邻近处理程序的执行顺序

```js
let p1 = Promise.resolve();
let p2 = Promise.reject();
p1.then(() => setTimeout(console.log, 0, 1));
p1.then(() => setTimeout(console.log, 0, 2));
// 1
// 2
p2.then(null, () => setTimeout(console.log, 0, 3));
p2.then(null, () => setTimeout(console.log, 0, 4));
// 3
// 4
p2.catch(() => setTimeout(console.log, 0, 5));
p2.catch(() => setTimeout(console.log, 0, 6));
// 5
// 6
p1.finally(() => setTimeout(console.log, 0, 7));
p1.finally(() => setTimeout(console.log, 0, 8));
// 7
// 8
```

:::

:::code 传递解决值和拒绝理由

```js
let p1 = new Promise((resolve, reject) => resolve("foo"));
p1.then(value => console.log(value)); // foo
let p2 = new Promise((resolve, reject) => reject("bar"));
p2.catch(reason => console.log(reason)); // bar

let p3 = Promise.resolve("foo");
p3.then(value => console.log(value)); // foo
let p4 = Promise.reject("bar");
p4.catch(reason => console.log(reason)); // bar
```

:::

:::code 期约连锁与期约合成

```js
let p1 = new Promise((resolve, reject) => reject(Error("foo")));
let p2 = new Promise((resolve, reject) => {
  throw Error("foo");
});
let p3 = Promise.resolve().then(() => {
  throw Error("foo");
});
let p4 = Promise.reject(Error("foo"));
setTimeout(console.log, 0, p1); // Promise <rejected>: Error: foo
setTimeout(console.log, 0, p2); // Promise <rejected>: Error: foo
setTimeout(console.log, 0, p3); // Promise <rejected>: Error: foo
setTimeout(console.log, 0, p4); // Promise <rejected>: Error: foo
//Uncaught (in promise) Error: foo 
//Uncaught (in promise) Error: foo 
//Uncaught (in promise) Error: foo 
//Uncaught (in promise) Error: foo 

new Promise((resolve, reject) => {
  console.log("begin asynchronous execution");
  reject(Error("bar"));
})
  .catch(e => {
    console.log("caught error", e);
  })
  .then(() => {
    console.log("continue asynchronous execution");
  });
// begin asynchronous execution
// caught error Error: bar
// continue asynchronous execution
```

:::

:::code 期约连锁与期约合成

```js
```

:::

:::code 期约扩展

```js
```

:::

## 异步函数

:::code 异步函数

```js
```

:::

:::code 停止和恢复执行

```js
```

:::
