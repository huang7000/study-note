# 语言基础

## 3.1 语法

:::tip 区分大小写和标识符

* 区分大小写：ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。
* 标识符就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成（驼峰大小写形式）：
    第一个字符必须是一个字母、下划线(_)或美元符号($)；
    剩下的其他字符可以是字母、下划线、美元符号或数字。
* 关键字、保留字、true、false 和 null 不能作为标识符。
:::

:::html 注释

``` js
//  let name="xiaobai"
/*
  多行注释
  let script=document.createElement("script");
  let script.src="demo.js";
  docunment.head.appendChild(script);
*/
let user="xiaonbai"
```

:::

:::html 严格模式是一种不同的JavaScript解析和执行模型，ES3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

``` js
  "use strict"  // 全局严格模式
```

``` js
  function doSomething(){
    "use strict"   // 局部严格模式
  }
```

:::

:::html 分号与if代码块

``` js
let a=5 // 没有分号也有效，不推荐
let b=10;// 加分号有效，强烈推荐
let sum = a + b;
if(sum>12)
  console.log(sum); //只有一条语句,可以不用代码块，但不推荐
if(sum<12){
  console.log(sum); //只有一条语句,也用代码块，强烈推荐
}
```

:::

## 3.2 关键字和保留字

:::tip 关键字
break       do          in            typeof
case        else        instanceof    var
catch       export      new           void
class       extends     return        while
const       finally     super         with
continue    for         switch        yield
debugger    function    this
default     if          throw
delete      import      try
:::

:::tip 保留字
始终保留:enum
严格模式下保留:
  implements  package     public
  interface   protected   static
  let         private
模块代码中保留:await
:::

:::tip JS中内置全局变量和函数
arguments             Error             Math            String
Array                 eval              NaN             super
Boolean               EvalError         Number          synchronized
Date                  Function          Object          throws
decodeURI             Infinity          parseFloat      transient
decodeURIComponent    isFinite          parseInt        volatile
encodeURI             isNaN             RangeError
encodeURIComponent    JSON              regExp
:::

## 3.3 变量

1. 不使用 var
2. const 优先，let 次之

:::html var关键字

```js
var message     // 定义一个名为message的变量，不初始化的情况下，变量会保存一个特殊值 undefined，不推荐不初始化
var userName = "hi"      // 定义并赋值，这个变量可以改变保存的值或类型
userName = 100            //// 合法，但不推荐,修改了值类型，正常只修改值不修改原来的数据类型
```

:::

:::html var声明 函数作用域

```js
//使用 var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁
function test() { 
 //var声明变量提升， 也就是把所有变量声明都拉到函数作用域的顶部。 
 //允许重复声明变量
 console.log(funMessage); // undefined
 var funMessage = "hi"; // 局部变量
} 
test(); 
console.log(funMessage); // 出错！

function testNo() { 
  funMessageNo = "hi"; // 在函数内定义变量时省略 var 操作符，可以创建一个全局变量。
  //var声明的全局变量会变成window 对象的属性
} 
testNo(); 
console.log(funMessageNo); //hi
```

:::

:::html let关键字
let 是块作用域、暂时性死区（不存在变量提升）、同一块作用域不允许重复声明（var、const声明的也不可以）
使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。

```js
let name="小白";
```

:::

:::html const关键字
const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且
尝试修改 const 声明的变量会导致运行时错误。
const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，
那么修改这个对象内部的属性并不违反 const 的限制。

```js
const age = 26; 
age = 36; // TypeError: 给常量赋值
const person = {}; 
person.name = 'Matt'; // ok
```

:::

## 3.4 数据类型

简单数据类型（原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。
复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。

:::html typeof 操作符
typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。

```js
let undefinedName = undefined;
let nullName = null;
let booleanName = true;
let numberName = 100;
let stringName = "xiaobai";
let symbolName = Symbol(123);
let objectName = { name: "xiaobai" };
let functionName = function () { };
let arrayName = [1, 2, 3];
console.log("undefinedName:" + typeof undefinedName);//undefinedName:undefined
console.log("nullName:" + typeof nullName);//nullName:object
console.log("booleanName:" + typeof booleanName);//booleanName:boolean
console.log("numberName:" + typeof numberName);//numberName:number
console.log("stringName:" + typeof stringName);//stringName:string
console.log("symbolName:" + typeof symbolName);//symbolName:symbol
console.log("objectName:" + typeof objectName);//objectName:object
console.log("functionName:" + typeof functionName);//functionName:function
console.log("arrayName:" + typeof arrayName);//arrayName:object
```

:::

:::html Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined。
undefined 是一个假值。

```js
let message; 
console.log(message === undefined); // true
let errorMessage = undefined; 
console.log(errorMessage === undefined); // true
console.log(typeof message); // "undefined" 

console.log(typeof age); // "undefined"
// let age 
console.log(age === undefined);//报错
```

:::

:::html Null 类型
Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，typeof返回"object"
null 是一个假值。

```js
let car = null; 
console.log(typeof car); // "object"
//undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等
console.log(null == undefined); // true
console.log(null === undefined); // false
```

:::

:::html Boolean 类型
Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。
这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。

```js
let found = true;
let lost = false;
console.log(found == 1)//true
console.log(lost == 0)//true
console.log(found === 1)//false
console.log(lost === 0)//false
```

:::

:::tip Number 数值
不同的数值类型相应地也有不同的数值字面量格式。
八进制值通过前缀 0o 来表示
十六进制值通过前缀 0x 来表示

```js
let intNum = 55; // 整数
let octalNum1 = 0o70;  // 八进制的 56 
let hexNum1 = 0xA; // 十六进制 10 
let hexNum2 = 0x1f; // 十六进制 31
//正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的
+0==-0  //true
+0===-0  //true
//非严格模式下
let octalNum3 = 070;  // 八进制的 56 
let octalNum4 = 079;  // 无效的八进制值，当成 79 处理
```

:::

:::tip Number 精度
Number 类型使用 IEEE 754 格式表示整数和浮点值（双精度值）。

```js
let a = 0.1;
let b = 0.2;
console.log(a + b);// 0.30000000000000004
//解决精度问题
console.log((a * 10 + b * 10) / 10);
console.log((a + b).toFixed(1));
console.log(a * b);// 0.020000000000000004
//解决精度问题
console.log((a * 10) * (b * 10) / 10);
console.log((a * b).toFixed(2));
```

:::

:::tip Number 值的范围
Number 类型使用 IEEE 754 格式表示整数和浮点值（双精度值）。

```js
let pMax = +Number.MAX_VALUE; //最大正数值
let pMin = +Number.MIN_VALUE; //最小精度正数值 
let nMax = -Number.MAX_VALUE; //最小负数值
let nMin = -Number.MIN_VALUE; //最小精度负数值 
let pMax = +Number.NEGATIVE_INFINITY; //最大正数值
let pMin = +Number.MIN_VALUE; //最小精度正数值 
let nMax = Number.POSITIVE_INFINITY; //最小负数值
let nMin = -Number.MIN_VALUE; //最小精度负数值 
console.log("pMax:" + pMax);// pMax:1.7976931348623157e+308
console.log("pMin:" + pMin);// pMin:5e-324
console.log("nMax:" + nMax);// nMax:-1.7976931348623157e+308
console.log("nMin:" + nMin);// nMin:-5e-324
console.log("pMax/nMax:" + pMax / nMax);//pMax/nMax:-1
console.log("isFinite(pMax/nMax):" + isFinite(pMax / nMax));//isFinite(pMax/nMax):true
console.log("pMax*nMax:" + pMax * nMax);// pMax*nMax:-Infinity
console.log("isFinite(pMax*nMax):" + isFinite(pMax * nMax));//isFinite(pMax*nMax):false

let numPOSITIVE = Number.POSITIVE_INFINITY;  //正无穷大
let numNEGATIVE = Number.NEGATIVE_INFINITY; //负无穷大
console.log("numPOSITIVE:" + numPOSITIVE) //numPOSITIVE:Infinity
console.log("isFinite(numPOSITIVE):" + isFinite(numPOSITIVE));// isFinite(numPOSITIVE):false
console.log("numNEGATIVE:" + numNEGATIVE);//numNEGATIVE:-Infinity
console.log("isFinite(numNEGATIVE):" + isFinite(numNEGATIVE));//isFinite(numNEGATIVE):false
console.log("numPOSITIVE+numPOSITIVE:" + (numPOSITIVE + numPOSITIVE)) //numPOSITIVE+numPOSITIVE:Infinity
console.log("isFinite(numPOSITIVE+numPOSITIVE):" + isFinite(numPOSITIVE + numPOSITIVE));// isFinit(numPOSITIVE+numPOSITIVE):false
console.log("numNEGATIVE-numPOSITIVE:" + (numNEGATIVE - numPOSITIVE));//numNEGATIVE-numPOSITIVE:-Infinity
console.log("isFinite(numNEGATIVE-numPOSITIVE):" + isFinite(numNEGATIVE - numPOSITIVE));//isFinit(numNEGATIVE-numPOSITIVE):false
console.log("numPOSITIVE*numPOSITIVE:" + (numPOSITIVE * numPOSITIVE)) //numPOSITIVE*numPOSITIVE:Infinity
console.log("isFinite(numPOSITIVE*numPOSITIVE):" + isFinite(numPOSITIVE * numPOSITIVE));// isFinit(numPOSITIVE*numPOSITIVE):false
console.log("numNEGATIVE/numPOSITIVE:" + (numNEGATIVE / numPOSITIVE));//numNEGATIVE/numPOSITIVE:NaN
console.log("isFinite(numNEGATIVE/numPOSITIVE):" + isFinite(numNEGATIVE / numPOSITIVE));//isFinit(numNEGATIVE/numPOSITIVE):false
```

:::

:::html Number Nan
有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。
首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10），在连续多步计算时这可能是个问题。
其次，NaN 不等于包括 NaN 在内的任何值。
ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。

```js
//在 ECMAScript 中，0、+0 或0 相除会返回 NaN：
//如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：
console.log(0 / 6); // 0 
console.log(-0 / 7); // -0
console.log(5 / 0); // Infinity 
console.log(5 / -0); // -Infinity
console.log(0 / 0); // NaN 
console.log(-0 / +0); // NaN
console.log(NaN == NaN); // false
console.log(Number.NaN == Number.NaN);// false
```

:::

:::html Number 数值转换 Number()
Number()转换数值
praseInt()转换整数
praseFloat()转化小数
*1（类似Number()）

```js
let strNum="123.456"
Number(strNum)
praseInt(strNum)
praseFloat(strNum)
strNum*1
```

:::

:::html Number 数值转换 Number()
Number()函数基于如下规则执行转换。

* 布尔值，true 转换为 1，false 转换为 0。
* 数值，直接返回。
* null，返回 0。
* undefined，返回 NaN。
* 字符串，应用以下规则。
  1. 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。
因此，Number("1")返回 1，Number("123")返回 123，Number("011")返回 11（忽略前面
的零）。
  2. 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值（同样，忽略前面的零）。
  3. 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整
数值。
  4. 如果是空字符串（不包含字符），则返回 0。
  5. 如果字符串包含除上述情况之外的其他字符，则返回 NaN。
* 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用
toString()方法，再按照转换字符串的规则转换。

```js
console.log(Number(true));// 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
console.log(Number("123"));//123
console.log(Number("+123"));//123
console.log(Number("-123"));//-123
console.log(Number("-123.123"));//-123.456
console.log(Number("0o123"));//83
console.log(Number("0x123"));//291
console.log(Number(""));// 0
console.log(Number("a123"));//NaN
console.log(Number("123b"));//NaN
console.log(Number("-123.456.789"));//NaN
console.log(Number(undefined));// NaN
console.log(Number([]));// 0
console.log(Number([1]));// 1
console.log(Number([1, 2]));// NaN
console.log(Number(["12"]));// 12
console.log(Number([12, "23"]));// NaN
console.log(Number(new Date()));//1612667468911
console.log(Number({}));// NaN
console.log(Number({ name: "xiaobai" }));// NaN
console.log(Number({ age: 18 }));// NaN
let testFun2 = function () {
  return;
}
console.log(Number(testFun2()));// NaN
let testFun1 = function (a) {
  return a;
}
console.log(Number(testFun1("ww")));// NaN
console.log(Number(testFun1(123)));// 123
```

:::

:::html Number 数值转换 praseInt()
parseInt()函数更专注于字符串是否包含数值模式。

* 字符串最前面的空格会被忽略，从第一个非空格字符开始转换。
* 如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN。这意味着空字符串也会返回 NaN（ Number()返回 0）。
* 如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。

```js
console.log(parseInt("1234blue")); // 1234 
console.log(parseInt("")); // NaN 
console.log(parseInt("0xA")); // 10，解释为十六进制整数
console.log(parseInt(22.5)); // 22 
console.log(parseInt("70")); // 70，解释为十进制值
console.log(parseInt("0xf")); // 15，解释为十六进制整数
console.log(parseInt("0xAF", 16)); // 175
console.log(parseInt("AF", 16)); // 175  提供了十六进制参数，字符串前面的"0x"可以省掉
console.log(parseInt("AF")); // NaN
console.log(parseInt("10", 2)); // 2，按二进制解析
console.log(parseInt("10", 8)); // 8，按八进制解析
console.log(parseInt("10", 10)); // 10，按十进制解析
console.log(parseInt("10", 16)); // 16，按十六进制解析
console.log(parseInt("3.125e7")); // 3
console.log(parseInt(".1234")); // NaN
```

:::

:::html Number 数值转换 praseFloat()
parseFloat()函数的工作方式跟 parseFloat()函数类似，

* 都是从位置 0 开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效
* parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨 论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。
* 最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 parseFloat()返回整数。
* 因为parseFloat()只解析十进制值，因此不能指定底数。十六进制数值始终会返回 0。八进制数值始终会返回 0。

```js
console.log(parseFloat("")); // NaN 
console.log(parseFloat("0xA")); // 0 十六进制数值始终会返回 0
console.log(parseFloat("0o7")); // 0 八进制数值始终会返回 0
console.log(parseFloat("1234blue"));   // 1234，按整数解析
console.log(parseFloat("0xA")); // 0 
console.log(parseFloat("22.5"));  // 22.5 
console.log(parseFloat("22.34.5"));  // 22.34 
console.log(parseFloat("0908.5")); // 908.5 
console.log(parseFloat("3.125e7")); // 31250000
console.log(parseFloat(".1234")); // 0.1234 
```

:::

:::html String

String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。
字符串可以使用双引号（"）、单引号（'）或反引号（`）标示。
以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。

```js
let firstName = "John"; 
let lastName = 'Jacob'; 
let fullName = `John Jacob`
//let fullName = `John Jacob" //  语法错误：开头和结尾的引号必须是同一种
```

:::

:::html String 字符字面量

| 字 面 量 | 含 义                                                                                            |
| -------- | ------------------------------------------------------------------------------------------------ |
| `\n`     | 换行                                                                                             |
| `\t`     | 制表                                                                                             |
| `\b`     | 退格                                                                                             |
| `\r`     | 回车                                                                                             |
| `\f`     | 换页                                                                                             |
| `\\`     | 反斜杠（\）                                                                                      |
| `\'`     | 单引号（'），在字符串以单引号标示时使用，例如'He said, \'hey.\''                                 |
| `\"`     | 双引号（"），在字符串以双引号标示时使用，例如"He said, \"hey.\""                                 |
| ` \`` `  | 反引号（` `` `）                                                                                 |
| `\xnn`   | 以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于"A"                      |
| `\unnnn` | 以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字符"Σ" |

```js
let strName1 = "John\nJacob";
let strName2 = "John\tJacob";
let strName3 = "John\bJacob";
let strName4 = "John\rJacob";
let strName5 = "John\fJacob";
let strName6 = "John\\Jacob";
let strName7 = "John\'Jacob";
let strName8 = "John\`Jacob";
let strName9 = "John\"Jacob";
let strName10 = "三国\x41诸葛亮";
let strName11 = "三国\u03a3诸葛亮";
```

:::

:::html String 转换方式

String()转型函数，它始终会返回表示相应类型值的字符串。String()函数遵循如下规则。

* 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。
* 如果值是 null，返回"null"。  如果值是 undefined，返回"undefined"。

null 和 undefined 值没有 toString()方法。其他类型几乎都有toString()方法
用加号操作符给一个值加上一个空字符串""也可以将其转换为字符串

```js
  let value1 = 10;
  let value2 = true;
  let value3 = null;
  let value4;
  console.log(String(value1)); // "10" 
  console.log(value1.toString()); // "10" 
  console.log(value1.toString(2)); // "1010" 
  console.log(String(value2)); // "true" 
  console.log(value2.toString()); // "10" 
  console.log(String(value3)); // "null" 
  console.log(String(value4)); // "undefined"
  console.log(value3 + ""); // 语法报错 
  console.log(value4 + ""); // 语法报错 
  console.log(value3.toString()); // 语法报错 
  console.log(value4.toString()); // 语法报错 
```

:::

:::html String 模板字面量

ECMAScript 6 新增了使用模板字面量定义字符串的能力(使用反引号`)。与使用单引号或双引号不同，模板字面量
保留换行字符，可以跨行定义字符串：

```js
  let strTemplate1 = 'first line\nsecond line';
  let strTemplate2 = `first line
second line`;
  let strTemplate3 = `first line
  second line`;
  console.log(strTemplate1);
  // first line 
  // second line
  console.log(strTemplate2);
  // first line 
  // second line
  console.log(strTemplate3);
  // first line 
  // second line
  console.log("strTemplate1.length:" + strTemplate1.length); //strTemplate1.length:22
  console.log("strTemplate2.length:" + strTemplate2.length); //strTemplate2.length:22
  console.log("strTemplate3.length:" + strTemplate3.length); //strTemplate3.length:24
  console.log(strTemplate1 == strTemplate2); //true
  console.log(strTemplate1 === strTemplate2); //true
  console.log(strTemplate2 === strTemplate3); //false
  let pageHTML = ` 
<div> 
 <a href="#"> 
 <span>Jake</span> 
 </a> 
</div>`;
```

:::

:::html String  字符串插值

模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。
技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。

```js
  const PI = 3.14;
  let radius = 5;
  let strName = "圆"

  // 以前，字符串插值是这样实现的：
  let strString = "园的半径：" + radius.toFixed(2) + "；直径：" + (radius * 2).toFixed(2) + "；周长：" + (PI * radius * 2).toFixed(2) + "；面积：" + (PI * radius * radius).toFixed(2);
  let strTemplate = `园的半径：${radius.toFixed(2)}；直径：${(radius * 2).toFixed(2)}；周长：${(PI * radius * 2).toFixed(2)}；面积：${(PI * radius * radius).toFixed(2)}`;
  console.log(strString); //  园的半径：5.00；直径：10.00；周长：31.40；面积：78.50
  console.log(strTemplate); // 园的半径：5.00；直径：10.00；周长：31.40；面积：78.50

  //嵌套的模板字符串无须转义：
  console.log(`Hello, ${`World`}!`); // Hello, World! 
  //将表达式转换为字符串时会调用 toString()：
  let foo = { toString: () => 'World' };
  console.log(`Hello, ${foo}!`); // Hello, World! 
  //在插值表达式中可以调用函数和方法：
  function capitalize(word) {
    return `${word[0].toUpperCase()}${word.slice(1)}`;
  }
  console.log(`${capitalize('hello')}, ${capitalize('world')}!`); // Hello, World! 
  //此外，模板也可以插入自己之前的值：
  let strValue = 'abc';
  console.log(strValue); //abc
  strValue = `${strValue}efg`;  //abcefg
  console.log(strValue); //abcefg
```

:::

:::html String  字符串插值

模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。
技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。

```js
  const PI = 3.14;
  let radius = 5;
  let strName = "圆"

  // 以前，字符串插值是这样实现的：
  let strString = "园的半径：" + radius.toFixed(2) + "；直径：" + (radius * 2).toFixed(2) + "；周长：" + (PI * radius * 2).toFixed(2) + "；面积：" + (PI * radius * radius).toFixed(2);
  let strTemplate = `园的半径：${radius.toFixed(2)}；直径：${(radius * 2).toFixed(2)}；周长：${(PI * radius * 2).toFixed(2)}；面积：${(PI * radius * radius).toFixed(2)}`;
  console.log(strString); //  园的半径：5.00；直径：10.00；周长：31.40；面积：78.50
  console.log(strTemplate); // 园的半径：5.00；直径：10.00；周长：31.40；面积：78.50

  //嵌套的模板字符串无须转义：
  console.log(`Hello, ${`World`}!`); // Hello, World! 
  //将表达式转换为字符串时会调用 toString()：
  let foo = { toString: () => 'World' };
  console.log(`Hello, ${foo}!`); // Hello, World! 
  //在插值表达式中可以调用函数和方法：
  function capitalize(word) {
    return `${word[0].toUpperCase()}${word.slice(1)}`;
  }
  console.log(`${capitalize('hello')}, ${capitalize('world')}!`); // Hello, World! 
  //此外，模板也可以插入自己之前的值：
  let strValue = 'abc';
  console.log(strValue); //abc
  strValue = `${strValue}efg`;  //abcefg
  console.log(strValue); //abcefg
```

:::

:::html String  模板字面量标签函数

模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。
标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。

```js
  let a = 6;
  let b = 9;
  function simpleTagOld(strings, aValExpression, bValExpression, sumExpression) {
    console.log(strings);
    console.log(aValExpression);
    console.log(bValExpression);
    console.log(sumExpression);
    return 'simpleTagOld';
  }
  function simpleTag(strings, ...expressions) {
    console.log(strings);
    for (const expression of expressions) {
      console.log(expression);
    }
    return 'simpleTag';
  }
  function zipTag(strings, ...expressions) {
    return strings[0] +
      expressions.map((e, i) => `${e}${strings[i + 1]}`)
        .join('');
  }
  let simpleTagOldResult = simpleTagOld`${a} + ${b} = ${a + b}`;
  // ["", " + ", " = ", ""] 
  // 6 
  // 9 
  // 15 
  let simpleTagResult = simpleTag`${a} + ${b} = ${a + b}`;
  // ["", " + ", " = ", ""] 
  // 6 
  // 9 
  // 15 
  let zipTagResult = zipTag`${a} + ${b} = ${a + b}`;
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  console.log(untaggedResult); // 6 + 9 = 15
  console.log(simpleTagOldResult); // simpleTagOld
  console.log(simpleTagResult); // simpleTag
  console.log(zipTagResult); // 6 + 9 = 15
```

:::
:::html String  原始字符串

使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。
可以使用默认的 String.raw 标签函数

```js
  console.log(`\u00A9`); // © 
  console.log(String.raw`\u00A9`); // \u00A9 
  // 换行符示例
  console.log(`first line\nsecond line`);
  // first line 
  // second line 
  console.log(String.raw`first line\nsecond line`); // "first line\nsecond line" 

  //也可以通过标签函数的第一个参数，即字符串数组的.raw 属性取得每个字符串的原始内容
  function printRaw(strings) {
    console.log(strings);
    console.log('Actual characters:');
    for (const string of strings) {
      console.log(string);
    }
    console.log('Escaped characters;');
    for (const rawString of strings.raw) {
      console.log(rawString);
    }
  }
  printRaw`\u00A9${'and'}\n`;
// ["©", "↵"]
// Actual characters:
// © 
//（换行符）
// Escaped characters: 
// \u00A9 
// \n
```

:::

## 3.5 操作符
