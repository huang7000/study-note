# 第 14 章 DOM

## 节点层级

:::code 节点层级

文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。
DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。
DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。

任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。
节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。
这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。

根节点的唯一子节点是`<html>`元素，我们称之为文档元素（documentElement）。
文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。

在 HTML 页面中，文档元素始终是`<html>`元素。
在 XML 文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。

HTML 中的每段标记都可以表示为这个树形结构中的一个节点。
元素节点表示 HTML 元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。
DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型: Node 类型。

```html
<html> 
 <head> 
 <title>Sample Page</title> 
 </head> 
 <body> 
 <p>Hello World!</p> 
 </body> 
</html>
```

:::

:::code Node 类型

DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。
Node 接口在 JavaScript中被实现为 Node 类型，在除 IE之外的所有浏览器中都可以直接访问这个类型。
在 JavaScript中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。
浏览器并不支持所有节点类型。

每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示：

- Node.ELEMENT_NODE（1）
- Node.ATTRIBUTE_NODE（2）
- Node.TEXT_NODE（3）
- Node.CDATA_SECTION_NODE（4）
- Node.ENTITY_REFERENCE_NODE（5）
- Node.ENTITY_NODE（6）
- Node.PROCESSING_INSTRUCTION_NODE（7）
- Node.COMMENT_NODE（8）
- Node.DOCUMENT_NODE（9）
- Node.DOCUMENT_TYPE_NODE（10）
- Node.DOCUMENT_FRAGMENT_NODE（11）
- Node.NOTATION_NODE（12）

:::

:::code Node 类型

DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。
Node 接口在 JavaScript中被实现为 Node 类型，在除 IE之外的所有浏览器中都可以直接访问这个类型。
在 JavaScript中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。
浏览器并不支持所有节点类型。

每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示：

- Node.ELEMENT_NODE（1）
- Node.ATTRIBUTE_NODE（2）
- Node.TEXT_NODE（3）
- Node.CDATA_SECTION_NODE（4）
- Node.ENTITY_REFERENCE_NODE（5）
- Node.ENTITY_NODE（6）
- Node.PROCESSING_INSTRUCTION_NODE（7）
- Node.COMMENT_NODE（8）
- Node.DOCUMENT_NODE（9）
- Node.DOCUMENT_TYPE_NODE（10）
- Node.DOCUMENT_FRAGMENT_NODE（11）
- Node.NOTATION_NODE（12）

:::

:::code Node 节点关系

```html
<!DOCTYPE html>
<html>
<body>
  <h1>JavaScript Demo</h1>
  <div>
    <p id="counter">
      <button id="start">Start</button>
      <button id="cancel">Cancel</button>
    </p>
  </div>

  <script>
    let someNode = document.getElementById("counter")
    console.log(someNode);
    //nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。
    console.log(someNode.nodeType) //1 Node.ELEMENT_NODE
    console.log(someNode.nodeName) // DIV
    console.log(someNode.nodeValue) //null
    //节点类型可通过与这些常量比较来确定
    if (someNode.nodeType == Node.ELEMENT_NODE) {
      console.log("Node is an ELEMENT_NODE.");
    }
    //节点关系 
    // 每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例。NodeList 是一个类数组对象，用于存储可以按位置存取的有序节点。
    console.log(someNode.childNodes.length); //5
    console.log(someNode.childNodes[1]); //<button id="start">Start</button>
    console.log(Array.from(someNode.childNodes)); //[text, button#start, text, button#cancel, text]

    //使用 previousSibling 和 nextSibling 可以在这个列表的节点间导航
    console.log(someNode.nextSibling); //#text
    console.log(someNode.previousSibling); //#text
    console.log(someNode.firstChild); //#text
    console.log(someNode.lastChild); //#text
    //ownerDocument 属性是一个指向代表整个文档的文档节点的指针。
    console.log(someNode.ownerDocument); //#document
    //每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素。
    console.log(someNode.parentNode); //<div>...</div>
  </script>
</body>
</html>
```

:::

:::code Node 方法

```js
let someNode = document.getElementById("counter")
console.log(someNode);
//appendChild()，用于在 childNodes 列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。appendChild()方法返回新添加的节点
var newNode = document.createElement('p')
newNode.textContent = '段落2'
let returnedNode = someNode.appendChild(newNode);
console.log(returnedNode == newNode); // true 
console.log(someNode.lastChild == newNode); // true
//如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置。
returnedNode = someNode.appendChild(someNode.firstChild);
console.log(returnedNode == someNode.firstChild); // false 
console.log(returnedNode == someNode.lastChild); // true
//如果想把节点放到 childNodes 中的特定位置而不是末尾，则可以使用 insertBefore()方法。两参数 要插入的节点和参照节点。
// 作为最后一个子节点插入
returnedNode = someNode.insertBefore(newNode, null);
console.log(newNode == someNode.lastChild); // true 
// 作为新的第一个子节点插入
returnedNode = someNode.insertBefore(newNode, someNode.firstChild);
console.log(returnedNode == newNode); // true 
console.log(newNode == someNode.firstChild); // true 
// 插入最后一个子节点前面
returnedNode = someNode.insertBefore(newNode, someNode.lastChild);
console.log(newNode == someNode.childNodes[someNode.childNodes.length - 2]); // true
//replaceChild()方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。
// 替换第一个子节点
returnedNode = someNode.replaceChild(newNode, someNode.firstChild);
// 替换最后一个子节点
returnedNode = someNode.replaceChild(newNode, someNode.lastChild);
//removeChild()方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回
// 删除第一个子节点
let formerFirstChild = someNode.removeChild(someNode.firstChild);
// 删除最后一个子节点
let formerLastChild = someNode.removeChild(someNode.lastChild);
//cloneNode()，会返回与调用它的节点一模一样的节点。cloneNode()方法接收一个布尔值参数，表示是否深复制。
let deepList = someNode.cloneNode(true);
console.log(deepList.childNodes.length); // 2
let shallowList = someNode.cloneNode(false);
console.log(shallowList.childNodes.length); // 0
//normalize()。这个方法唯一的任务就是处理文档子树中的文本节点。
console.log(someNode.childNodes.length); //2
someNode.normalize()
console.log(someNode.childNodes.length); //2
```

:::

:::code Document 类型

Document 类型是 JavaScript 中表示文档节点的类型。
在浏览器中，文档对象 document 是HTMLDocument 的实例（HTMLDocument 继承 Document），表示整个 HTML 页面。

Document 类型的节点有以下特征：

- nodeType 等于 9；
- nodeName 值为"#document"；
- nodeValue 值为 null；
- parentNode 值为 null；
- ownerDocument 值为 null；
- 子节点可以是 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或 Comment 类型。

文档类型（如果存在）是只读的，而且只能有一个 Element 类型的子节点（即`<html>`，已经存在了）。
appendChild()、removeChild()和 replaceChild()方法不会用在 document 对象上。

```js
//文档子节点
let html = document.documentElement; // 取得对<html>的引用
let body = document.body; // 取得对<body>的引用
let doctype = document.doctype; // 取得对<!doctype>的引用

//文档信息
let title = document.title;
let url = document.URL; // 取得完整的 URL 
let domain = document.domain; // 取得域名
let referrer = document.referrer;// 取得来源
//在这些属性中，只有 domain 属性是可以设置的。出于安全考虑，给 domain 属性设置的值是有限。
//不能给 domain 设置 URL 中不包含的值
// 页面来自 p2p.wrox.com 
document.domain = "wrox.com"; // 成功
document.domain = "nczonline.net"; // 出错！
//浏览器对 domain 属性还有一个限制，即这个属性一旦放松就不能再收紧。
 // 页面来自 p2p.wrox.com 
document.domain = "wrox.com"; // 放松，成功
document.domain = "p2p.wrox.com"; // 收紧，错误！
```

:::

:::code  Document 定位元素

- getElementById()方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果没找到则返回 null。
- getElementsByTagName()是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的NodeList。
- getElementsByName()方法会返回具有给定 name 属性的所有元素。getElementsByName()方法最常用于单选按钮。

```html
<div id="myDiv" name="myDiv">Some text</div>
<script>
  let someNode = document.getElementById("counter");
  let myDivId = document.getElementById("myDiv");
  let myDivName = document.getElementsByName("myDiv");
  let myDivTagName = document.getElementsByTagName("div");
  console.log(myDivId);//Node
  console.log(myDivTagName);//HTMLCollection
  console.log(myDivName);//NodeList
  console.log(myDivName == myDivTagName);//false
  console.log(myDivName[0] == myDivId);//true
  console.log(myDivTagName[0] == myDivId);//true
</script>
```

:::

:::code  Document 文档写入

write()和 writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中。
write()简单地写入文本，而 writeln()还会在字符串末尾追加一个换行符（\n）。
open()和 close()方法分别用于打开和关闭网页输出流。
write()和 writeln()方法经常用于动态包含外部资源，如 JavaScript 文件。

```js
document.write("<script type=\"text/javascript\" src=\"file.js\"><\/script>");
```

:::

:::code  Document 特殊集合

document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是
访问文档中公共部分的快捷方式，列举如下。

- document.anchors 包含文档中所有带 name 属性的`<a>`元素。
- document.forms 包含文档中所有`<form>`元素（与 document.getElementsByTagName ("form")返回的结果相同）。
- document.images 包含文档中所有`<img>`元素（与 document.getElementsByTagName ("img")返回的结果相同）。
- document.links 包含文档中所有带 href 属性的`<a>`元素。

:::

:::code Element 类型

Element 表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。Element 类型的节点具有以下特征：

- nodeType 等于 1；
- nodeName 值为元素的标签名；
- nodeValue 值为 null；
- parentNode 值为 Document 或 Element 对象；
- 子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference 类型。

```html
<div id="myDiv"></div>
<script>
  let div = document.getElementById("myDiv");
  //样取得这个元素的标签名
  console.log(div.tagName); // "DIV" 
  console.log(div.tagName == div.nodeName); // true
  //在 HTML 中，元素标签名始终以全大写表示；在 XML（包括 XHTML）中，标签名始终与源代码中的大小写一致。
  if (div.tagName == "div") { // 不要这样做，可能出错！
    // do something here 
  }
  if (div.tagName.toLowerCase() == "div") { // 推荐，适用于所有文档
    // 做点什么
  }
</script>
```

:::

:::code Element HTML 元素
所有 HTML 元素都通过 HTMLElement 类型表示，包括其直接实例和间接实例。
HTMLElement直接继承 Element 并增加了一些属性，所有 HTML 元素上都有的标准属性：

- id，元素在文档中的唯一标识符；
- title，包含元素的额外信息，通常以提示条形式展示；
- className，相当于 class 属性，用于指定元素的 CSS 类（因为 class 是 ECMAScript 关键字，所以不能直接用这个名字）
- lang，元素内容的语言代码（很少用）；
- dir，语言的书写方向（"ltr"表示从左到右，"rtl"表示从右到左，同样很少用）；

```html
<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr">123258147963</div>
<script>
  let div = document.getElementById("myDiv");
  console.log(div.id); // "myDiv" 
  console.log(div.className); // "bd" 
  console.log(div.title); // "Body text" 
  console.log(div.lang); // "en" 
  console.log(div.dir); // "ltr"
  //可以使用下列代码修改元素的属性：
  div.id = "someOtherId";
  div.className = "ft";
  div.title = "Some other text";
  div.lang = "fr";
  div.dir = "rtl";
</script>
```

:::

:::code Element 属性

getAttribute()：取得属性。
setAttribute()：设置属性。
removeAttribute()：删除属性。

```html
<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr">123258147963</div>
<script>
  let div = document.getElementById("myDiv");
  //属性名不区分大小写，因此"ID"和"id"被认为是同一个属性。
  //根据 HTML5 规范的要求，自定义属性名应该前缀 data-以方便验证。
  //取得属性 
  console.log(div.getAttribute("ID")); // "myDiv" 
  console.log(div.getAttribute("id")); // "myDiv" 
  console.log(div.getAttribute("class")); // "bd"   // getAttribute()的属性名与它们实际的属性名是一样的，因此这里要传"class"而非"className"
  console.log(div.getAttribute("title")); // "Body text" 
  console.log(div.getAttribute("lang")); // "en" 
  console.log(div.getAttribute("dir")); // "ltr"

  //设置属性
  div.setAttribute("id", "someOtherId");
  div.setAttribute("class", "ft");
  div.setAttribute("title", "Some other text");
  div.setAttribute("lang", "fr");
  div.setAttribute("dir", "rtl");
  div.setAttribute("data-attr", "data-attr");
  console.log(div.getAttribute("data-attr")); // data-attr
  //注意，在 DOM 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：
  div.datacolor = "red";
  console.log(div.getAttribute("datacolor")); // null

  //删除属性
  div.removeAttribute("class");
  console.log(div.getAttribute("class")); // null
</script>
```

:::

:::code Element attributes 属性

Element 类型是唯一使用 attributes 属性的 DOM 节点类型。
attributes 属性包含一个NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。
元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。

NamedNodeMap 对象包含下列方法：

- getNamedItem(name)，返回 nodeName 属性等于 name 的节点；
- removeNamedItem(name)，删除 nodeName 属性等于 name 的节点；
- setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引；
- item(pos)，返回索引位置 pos 处的节点。

```html
<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr">123258147963</div>
<script>
  let div = document.getElementById("myDiv");
  //getNamedItem
  let id1 = div.attributes.getNamedItem("id").nodeValue;//myDiv
  //使用中括号访问属性的简写形式：
  let id2 = div.attributes["id"].nodeValue;//myDiv
  //用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值.
  div.attributes["id"].nodeValue = "someOtherId";
  //是removeNamedItem()返回表示被删除属性的Attr节点
  let oldAttr = div.attributes.removeNamedItem("id");//id="someOtherId"
  //setNamedItem()方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：
  var id = document.createAttribute("id");
  id.nodeValue = "myDiv";
  div.attributes.setNamedItem(id);//id="myDiv"
</script>
```

:::

:::code Element 创建元素

使用 document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。
在 HTML 文档中，标签名是不区分大小写的，而 XML 文档（包括 XHTML）是区分大小写的。
要把元素添加到文档树，可以使用 appendChild()、insertBefore()或 replaceChild()。

childNodes属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。

```html
<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr">123258147963</div>
<ul id="myList1">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
<ul id="myList2"><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>
<script>
  let div = document.getElementById("myDiv");
  //创建新节点
  let divNew = document.createElement("div");
  divNew.id = "myNewDiv";
  divNew.className = "box";
  divNew.innerHTML = "创建"
  div.appendChild(divNew);
  //元素后代
  let myList1 = document.getElementById("myList1");
  let myList2 = document.getElementById("myList2");
  let items1 = myList1.getElementsByTagName("li");
  let items2 = myList2.getElementsByTagName("li");
  console.log(myList1.childNodes);//包含 7 个子元素，其中 3 个是<li>元素，还有 4 个 Text 节点（表示<li>元素周围的空格）。
  console.log(myList2.childNodes);//<ul>元素都会包含 3 个子节点。
</script>
```

:::

:::code Text 类型

Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。
Text 类型的节点具有以下特征：

- nodeType 等于 3；
- nodeName 值为"#text"；
- nodeValue 值为节点中包含的文本；
- parentNode 值为 Element 对象；
- 不支持子节点。

文本节点暴露了以下操作文本的方法：

- appendData(text)，向节点末尾添加文本 text；
- deleteData(offset, count)，从位置 offset 开始删除 count 个字符；
- insertData(offset, text)，在位置 offset 插入 text；
- replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的文本；
- plitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点；
- substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。

通过 length 属性获取文本节点中包含的字符数量。这个值等于 nodeValue. length 和 data.length。

```html
<!-- 没有内容，因此没有文本节点 -->
<div id="myDiv1"></div>
<!-- 有空格，因此有一个文本节点 -->
<div id="myDiv2"> </div>
<!-- 有内容，因此有一个文本节点 -->
<div id="myDiv3">Hello World!</div>
<!-- 有内容，因此有一个文本节点 -->
<div id="myDiv4">
</div>
<div id="myDiv5">
  Hello World!
</div>
<script>
  let myDiv1 = document.getElementById("myDiv1");
  let myDiv2 = document.getElementById("myDiv2");
  let myDiv3 = document.getElementById("myDiv3");
  let myDiv4 = document.getElementById("myDiv4");
  let myDiv5 = document.getElementById("myDiv5");
  console.log(myDiv1.childNodes);//length 0 
  console.log(myDiv2.childNodes);//length 1 nodeValue: " "
  console.log(myDiv3.childNodes);//length 1 nodeValue: "Hello World!"
  console.log(myDiv4.childNodes);//length 1 nodeValue: "↵↵  "
  console.log(myDiv5.childNodes);//length 1 nodeValue: "↵    Hello World!↵  "
  let textNode = myDiv2.firstChild; // 或 div.childNodes[0] 
  //取得文本节点的引用后，可以像这样来修改它：
  myDiv2.firstChild.nodeValue = "Some other message";
  //创建文本节点
  let element = document.createElement("div");
  element.className = "message";
  element.id = "testDiv";
  //一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点
  let textNodeNew = document.createTextNode("Hello world!");
  element.appendChild(textNodeNew);
  let anotherTextNode = document.createTextNode("Yippee!");
  element.appendChild(anotherTextNode);
  document.body.appendChild(element);
  let testDiv = document.getElementById("testDiv");
  console.log(element.childNodes.length); // 2 
  element.normalize();//规范化文本节点
  console.log(element.childNodes.length); // 1 
  //splitText()。这个方法可以在指定的偏移位置拆分 nodeValue，将一个文本节点拆分成两个文本节点。
  let newNode = element.firstChild.splitText(5);
  console.log(element.firstChild.nodeValue); // "Hello" 
  console.log(newNode.nodeValue); // " world!Yippee!" 
  console.log(element.childNodes.length); // 2
</script>
```

:::

:::code Comment 类型

DOM 中的注释通过 Comment 类型表示。
Comment 类型的节点具有以下特征：

- nodeType 等于 8；
- nodeName 值为"#comment"；
- nodeValue 值为注释的内容；
- parentNode 值为 Document 或 Element 对象；
- 不支持子节点。

Comment 类型与 Text 类型继承同一个基类（CharacterData），因此拥有除 splitText()之外Text 节点所有的字符串操作方法。
与 Text 类型相似，注释的实际内容可以通过 nodeValue 或 data属性获得。

```html
<div id="myDiv">
  <!-- A comment -->
</div>
<script>
  let div = document.getElementById("myDiv");
  console.log(div);
  let comment = div.firstChild;
  console.log(comment.data); // "A comment" 
  //可以使用 document.createComment()方法创建注释节点，参数为注释文本，如下所示：
  let comment1 = document.createComment("A comment");
</script>
```

:::

:::code CDATASection 类型

CDATASection 类型表示 XML 中特有的 CDATA 区块。
CDATASection 类型继承 Text 类型，因此拥有包括 splitText()在内的所有字符串操作方法。

CDATASection 类型的节点具有以下特征：

- nodeType 等于 4；
- nodeName 值为"#cdata-section"；
- nodeValue 值为 CDATA 区块的内容；
- parentNode 值为 Document 或 Element 对象；
- 不支持子节点。

```html
<div id="myDiv"><![CDATA[This is some content.]]></div>
```

:::

:::code DocumentType 类型

DocumentType 类型的节点包含文档的文档类型（doctype）信息，具有以下特征：

- nodeType 等于 10；
- nodeName 值为文档类型的名称；
- nodeValue 值为 null；
- parentNode 值为 Document 对象；
- 不支持子节点。

DOM Level 1 规定了DocumentType 对象的 3 个属性：name、entities 和 notations。
name 是文档类型的名称，
entities 是这个文档类型描述的实体的 NamedNodeMap，
notations 是这个文档类型描述的表示法的 NamedNodeMap。

```js
console.log(document.doctype.name); // "html"
```

:::

:::code DocumentFragment 类型
在所有节点类型中，DocumentFragment 类型是唯一一个在标记中没有对应表示的类型。
DOM 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。

DocumentFragment 节点具有以下特征：

- nodeType 等于 11；
- nodeName 值为"#document-fragment"；
- nodeValue 值为 null；
- parentNode 值为 null；
- 子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或EntityReference。

```html
<ul id="myList"></ul>
<script>
  let fragment = document.createDocumentFragment();
  let ul = document.getElementById("myList");
  for (let i = 0; i < 3; ++i) {
    let li = document.createElement("li");
    li.appendChild(document.createTextNode(`Item ${i + 1}`));
    fragment.appendChild(li);
  }
  ul.appendChild(fragment);
</script>
```

:::

:::code Attr 类型
元素数据在 DOM 中通过 Attr 类型表示。Attr 类型构造函数和原型在所有浏览器中都可以直接访问。
技术上讲，属性是存在于元素 attributes 属性中的节点。Attr 节点具有以下特征

- nodeType 等于 2；
- nodeName 值为属性名；
- nodeValue 值为属性值；
- parentNode 值为 null；
- 在 HTML 中不支持子节点；
- 在 XML 中子节点可以是 Text 或 EntityReference。
  
```html
<div id="myDiv"></div>
<script>
  let element = document.getElementById("myDiv");
  let attr = document.createAttribute("align");
  attr.value = "left";
  element.setAttributeNode(attr);
  console.log(element.attributes["align"].value); // "left" 
  console.log(element.getAttributeNode("align").value); // "left" 
  console.log(element.getAttribute("align")); // "left"
</script>
```

:::

## DOM 编程

:::code 动态脚本

```js
```

:::

:::code 动态样式

```js
```

:::

:::code 操作表格

```js
```

:::

:::code 使用 NodeList

```js
```

:::

## MutationObserver 接口

:::code 基本用法

```js
```

:::

:::code MutationObserverInit 与观察范围

```js
```

:::

:::code 异步回调与记录队列

```js
```

:::

:::code 性能、内存与垃圾回收

```js
```

:::
